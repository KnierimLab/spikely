[{"element_cls_name": "Extractor", "element_mod_name": "spikely.elements.extractor", "spif_cls_name": "MEArecRecordingExtractor", "spif_mod_name": "spikeextractors.extractors.mearecextractors.mearecextractors", "param_list": [{"name": "file_path", "type": "file", "title": "Path to file (.h5 or .hdf5)", "value": "/afs/inf.ed.ac.uk/user/s17/s1727843/spiketutorials/Spike_sorting_workshop_2019/recordings_36cells_four-tetrodes_30.0_10.0uV_20-06-2019_14_48.h5"}, {"name": "probe_path", "type": "file", "title": "Path to probe file (.csv or .prb)", "default": null, "value": "/afs/inf.ed.ac.uk/user/s17/s1727843/spiketutorials/Spike_sorting_workshop_2019/tetrode_16.prb"}, {"name": "channel_map", "type": "int_list", "value": null, "default": null, "title": "List of channel ids for underlying             channels to be be mapped. If None, then uses default ordering."}, {"name": "channel_groups", "type": "int_list", "value": null, "default": null, "title": "List of channel groups of the             underlying channels. If None, then no groups given."}]}, {"element_cls_name": "Preprocessor", "element_mod_name": "spikely.elements.preprocessor", "spif_cls_name": "BandpassFilterRecording", "spif_mod_name": "spiketoolkit.preprocessing.bandpass_filter", "param_list": [{"name": "freq_min", "type": "float", "value": 300.0, "default": 300.0, "title": "Low-pass frequency"}, {"name": "freq_max", "type": "float", "value": 6000.0, "default": 6000.0, "title": "High-pass frequency"}, {"name": "freq_wid", "type": "float", "value": 1000.0, "default": 1000.0, "title": "Width of the filter (when type is 'fft')"}, {"name": "type", "type": "str", "value": "fft", "default": "fft", "title": "Filter type ('fft' or 'butter')"}, {"name": "order", "type": "int", "value": 3, "default": 3, "title": "Order of the filter (if 'butter')"}, {"name": "chunk_size", "type": "int", "value": 30000, "default": 30000, "title": "Chunk size for the filter."}, {"name": "cache", "type": "bool", "value": false, "default": false, "title": "If True filtered traces are computed and cached"}]}, {"element_cls_name": "Sorter", "element_mod_name": "spikely.elements.sorter", "spif_cls_name": "Mountainsort4Sorter", "spif_mod_name": "spikesorters.mountainsort4.mountainsort4", "param_list": [{"name": "output_folder", "type": "folder", "value": null, "default": null, "title": "Sorting output folder path", "base_param": true}, {"name": "grouping_property", "type": "str", "value": null, "default": null, "title": "Will sort the recording by the given property ('group', etc.)", "base_param": true}, {"name": "parallel", "type": "bool", "value": false, "default": false, "title": "If the recording is sorted by a property, then it will do this in parallel", "base_param": true}, {"name": "delete_output_folder", "type": "bool", "value": false, "default": false, "title": "If True, delete the results of the sorter, otherwise, it won't.", "base_param": true}, {"name": "detect_sign", "type": "int", "value": -1, "default": -1, "title": "Use -1, 0, or 1, depending on the sign of the spikes in the recording"}, {"name": "adjacency_radius", "type": "float", "value": -1, "default": -1, "title": "Use -1 to include all channels in every neighborhood"}, {"name": "freq_min", "type": "float", "value": 300.0, "default": 300.0, "title": "Low-pass frequency"}, {"name": "freq_max", "type": "float", "value": 6000.0, "default": 6000.0, "title": "High-pass frequency"}, {"name": "filter", "type": "bool", "value": false, "default": false, "title": "Bandpass filters the recording if True"}, {"name": "whiten", "type": "bool", "value": true, "default": true, "title": "Whitens the recording if True"}, {"name": "curation", "type": "bool", "value": false, "default": false, "title": "Curates the output if True"}, {"name": "num_workers", "type": "int", "value": null, "default": null, "title": "Number of parallel workers"}, {"name": "clip_size", "type": "int", "value": 50, "default": 50, "title": "Clip size"}, {"name": "detect_threshold", "type": "float", "value": 3.0, "default": 3.0, "title": "Threshold for detection"}, {"name": "detect_interval", "type": "int", "value": 10, "default": 10, "title": "Minimum number of timepoints between events detected on the same channel"}, {"name": "noise_overlap_threshold", "type": "float", "value": 0.15, "default": 0.15, "title": "Use None for no automated curation"}]}, {"element_cls_name": "Curator", "element_mod_name": "spikely.elements.curator", "spif_cls_name": "ThresholdNumSpikes", "spif_mod_name": "spiketoolkit.curation.threshold_num_spikes", "param_list": [{"name": "threshold", "type": "float", "value": 100, "default": 100, "title": "The threshold for the given metric."}, {"name": "threshold_sign", "type": "str", "value": "less", "default": "less", "title": "If 'less', will threshold any metric less than the given threshold. If 'greater', will threshold any metric greater than the given threshold."}]}, {"element_cls_name": "Exporter", "element_mod_name": "spikely.elements.exporter", "spif_cls_name": "PhyExporter", "spif_mod_name": "spikely.elements.phy_exporter", "param_list": [{"name": "save_path", "type": "folder", "title": "Save path", "value": "results_phy"}, {"name": "nPC", "type": "int", "value": 3, "default": 3, "title": "Number of principal components"}, {"name": "electrode_dimensions", "type": "int_list", "value": null, "default": null, "title": "If electrode locations are 3D, it indicates the 2D dimensions to use as channel location."}, {"name": "grouping_property", "type": "str", "value": null, "default": null, "title": "Property to group channels. E.g. if the recording extractor has the 'group' property and 'grouping_property' is 'group', then waveforms are computed group-wise."}, {"name": "ms_before", "type": "float", "value": 1.0, "default": 1.0, "title": "Time period in ms to cut waveforms before the spike events."}, {"name": "ms_after", "type": "float", "value": 2.0, "default": 2.0, "title": "Time period in ms to cut waveforms after the spike events."}, {"name": "dtype", "type": "np.dtype", "value": null, "default": null, "title": "The dtype of underlying data (int16, float32, etc.)"}, {"name": "amp_method", "type": "str", "value": "absolute", "default": "absolute", "title": "If 'absolute' (default), amplitudes are absolute amplitudes in uV are returned. If 'relative', amplitudes are returned as ratios between waveform amplitudes and template amplitudes."}, {"name": "amp_peak", "type": "str", "value": "both", "default": "both", "title": "If maximum channel has to be found among negative peaks ('neg'), positive ('pos') or both ('both' - default)."}, {"name": "amp_frames_before", "type": "int", "value": 3, "default": 3, "title": "Frames before peak to compute amplitude."}, {"name": "amp_frames_after", "type": "int", "value": 3, "default": 3, "title": "Frames after peak to compute amplitude."}, {"name": "max_num_waveforms", "type": "int", "value": Infinity, "default": Infinity, "title": "The maximum number of waveforms to extract. If 'inf', it will use all the waveforms."}, {"name": "max_num_pca_waveforms", "type": "int", "value": Infinity, "default": Infinity, "title": "The maximum number of waveforms used to compute PCA. If 'inf', it will use all the waveforms."}, {"name": "write_waveforms", "type": "bool", "value": false, "default": false, "title": "If True, waveforms are saved as waveforms.npy."}, {"name": "seed", "type": "int", "value": 0, "default": 0, "title": "Random seed for extracting waveforms and pcs."}]}]